# Директива Include и разделение файлов

## Include

### Как работает #include

Обработка исходных файлов компилятором происходит в несколько [стадий](https://en.cppreference.com/w/cpp/language/translation_phases#Phase_4). На одной из стадий (четвертой) происходит обработка препроцессором. [Препроцессор](https://en.cppreference.com/w/cpp/preprocessor) использует директивы для определения своего поведения.

Директива [#include](https://en.cppreference.com/w/cpp/preprocessor/include) включает в обрабатываемый препроцессором исходный файл сразу после директивы тот файл, которой указан в директиве.

В данном случае лучше посмотреть на пример.

Есть два файла:

```folder
project
| main.cpp
| sum.cpp
```

Код sum.cpp:

```cpp
int sum(int a, int b) {
    return a + b;
}
```

Фаил main.cpp включает в себя sum.cpp:

```cpp
#include "sum.cpp" // В некоторых случаях используются угловые скобки, в некоторых двойные кавычки - об этом будет далее

int main()
{
    int result = sum(5, 1);
    return 0;
}
```

Результатом препроцессинга будет единый файл, который в дальнейшем будет подан компилятору:

```cpp
int sum(int a, int b) {
    return a + b;
}

int main()
{
    int result = sum(5, 1);
    return 0;
}
```

### Различия в использовании угловых скобок и кавычек

В [справке](https://en.cppreference.com/w/cpp/preprocessor/include) указаны различия. Но мне они не очень понятны (что такое h-char-sequence и q-char-sequence? что означают в них h и q? В каки случаях применять угловые скобки, а в каких кавычки?).

Большее понимание даёт [stackoverflow](https://stackoverflow.com/questions/21593/what-is-the-difference-between-include-filename-and-include-filename).

Угловые скобки используются для включения в файл кода, который определен в стандартной библиотеке (т.е. файлов, которые не разработаны в рамках проекта). Например `#include \<iostream>`. Кавычки для включения файлов текущего проекта. Например `#include "sum.cpp"` в разделе выше.

При этом в некоторых случаях, например при использовании в Qt qmake или Qml c cmake можно для файлов проекта применять угловые скобки. А в остальных случаях (например,простое приложение С++ с cmake) выдает ошибку `'filename.cpp' file not found with \<angled> include; use "quotes" instead (fix available)`.

Поэтому для уменьшения вероятности появления ошибки лучше использовать угловые скобки для стандартной библиотеки и кавычки для файлов проекта.

Всегда смущали используемые сокращения, когда непонятно, что они означают, т.к. когда известно значение, появляется большее понимание смысла. Найти, что означают h и q (в h-char-sequence и q-char-sequence) не удалось, поэтому предположу. h скорее всего сокращение от header, т.к. в угловых скобках используются заголовки (хотя только и из стандартной библиотеки). q скорее всего сокращение от quot (кавычки), т.к используется в кавычках.

TODO: Проверить, как надо подключать стороннюю библиотеку, но подключенную к своему проекту. Предположительно через кавычки

### Использование имени класса в #include (на самом деле нет)

При разработке в Qt может показаться, что используется имя класса в #include (Например, `#include <QGuiApplication>`). [На самом деле](https://stackoverflow.com/questions/37460286/c-are-there-benefits-of-using-include-classname-instead-of-include-clas), просто создается обычный текстовый файл с таким именем без расширения содержащий одну строчку #include <qguiapplication.h>.

При этом, если оба файла указаны при компиляции, то может появиться ошибка `P:\cpp\fun\plan\sum.cpp:3: error: multiple definition of sum(int, int); CMakeFiles/plan.dir/main.cpp.obj:P:/cpp/fun/plan/sum.cpp:3: first defined here`. Как с этим бороться указано в следующем подразделе.

### Директива #ifndef

Для исключения дублирования кода и появления ошибки (как указано в предыдущем подразделе) можно использовать pragma, но это не стандартно, как указано в [статье](https://en.cppreference.com/w/cpp/preprocessor/include) (Many compilers also implement the non-standard pragma #pragma once with similar effects: it disables processing of a file if the same file (where file identity is determined in OS-specific way) has already been included.)

В Qt используется директива #ifndef (означает - [if not defined, если не определено](https://uchet-jkh.ru/i/ifndef-c-cto-eto/))

```cpp
#ifndef FF_H
#define FF_H

class ff
{
public:
    ff();
};

#endif // FF_H
```

Т.е. если не определено какое-то значение (по сути имя класса и буквы H - от header) то оно определяется `#define FF_H` и в следующий раз этот код уже не загружается.

### non-related function

В Qt в справочной информации можно встретить non-related function. Т.е. функции, которые не являются функциями класса, но при этом при имитации импорта по имени класса эти функции доступны. Почему это происходит?

Т.к. в С++ происходит просто включение кода из разных файлов в один, то при включении файла, в котором до этого уже включен файл в этими функциями, то все работает.

### Пояснения, почему надо включать файл с типом, который в явном виде не упоминается в коде, но используются его члены

Для меня вначале было неожиданностью, что надо ссылаться на файл, содержащий функции для класса, который в явном виде не упоминается в коде.

```cpp
#include <QGuiApplication>
#include <QQmlApplicationEngine>

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;
    const QUrl url(u"qrc:/test/Main.qml"_qs);
   
    engine.rootContext()->setContextProperty("textContent", "Hello"); // эта строчка выдаст ошибку
    
    engine.load(url);

    return app.exec();
}

```

Строка `engine.rootContext()->setContextProperty("textContent", "Hello");` выдаст ошибку `P:\cpp\fun\test\main.cpp:11: error: Member access into incomplete type 'QQmlContext'`, т.к. метод `rootContext()` [возвращает](https://doc.qt.io/qt-6/qqmlengine.html#rootContext) [QQmlContext](https://doc.qt.io/qt-6/qqmlcontext.html) информация о реализации функций которого не включена в этот файл. Поэтому надо добавить `#include <QQmlContext>` и все будет работать.

## Разделение файла класса на заголовочный .h и .cpp

При разработке классов часто предусматривают разделение на заголовочный файл и файл с реализацией. На начальном этапе достаточно сложно понять мотивацию такого разделения. При этом, для понимания объяснений надо все же, видимо, обладать большими знаниями. Поэтому напишу как понял в данный момент.

Одной из основных причин называют повышение производительности:

- объясняют [предварительно откомпилированными заголовками](https://ru.wikipedia.org/wiki/Предварительно_откомпилированные_заголовки)
- а также тем, что нет необходимости повторно компилировать те файлы, которые не изменили (возможно это связано и с предыдущим пунктом).

Это все работает, т.к. при компиляции вначале текстовые файлы преобразуются в O-файлы, которые только после этого соединяются вместе.

Но повторюсь, я имею довольно поверхностное представление об этом и на данном этапе в общем объяснение для меня такое: Так сложилось, что лучше файлы разделять, все понимают как это делать, поэтому надо делать так же.

Но тогда становится не совсем очевидным ответ на вопрос: "Почему при использовании в рамках разделения одного класса на заголовочный файл и файл, содержащий реализацию функций, #include размещают в файле реализации со ссылкой на заголовочный файл, а не в заголовочном файле со ссылкой на .cpp.

Тут достаточно все очевидно. Когда определяется класс вначале должно быть определение класса, и только затем происходит реализация (что достаточно интуитивно понятно).

Но почему тогда в других файлах, которые используют этот класс, в #include указывают только заголовочный файл, а не файл с реализацией (ведь он содержит в себе ссылку на заголовочный файл!!!)?

Понятного для себя объяснения я не нашел. В целом, в настоящий момент восприятие такое: Так это устроено, что можно добавить только заголовочный файл.

В объяснениях обычно [говорят](https://stackoverflow.com/questions/1686204/why-should-i-not-include-cpp-files-and-instead-use-a-header), что в заголовочном файле содержится достаточно информации для компиляции. Видимо далее компилятор просто знает где взять реализацию. Поэтому это надо просто принять:)

Компилятору же [подаются все файлы](https://stackoverflow.com/questions/3202136/using-g-to-compile-multiple-cpp-and-h-files) и заголовочные и файлы с реализацией.
